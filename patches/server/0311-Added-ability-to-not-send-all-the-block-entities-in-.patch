From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Maki325 <no-reply@maki325.me>
Date: Wed, 22 Feb 2023 23:56:30 +0100
Subject: [PATCH] Added ability to not send all the block entities in the
 chunk, just the visible ones


diff --git a/src/main/java/me/maki325/ocelot/OcelotConfig.java b/src/main/java/me/maki325/ocelot/OcelotConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..41371a9d0881bbf85636a0e08b20e1643ef2b46d
--- /dev/null
+++ b/src/main/java/me/maki325/ocelot/OcelotConfig.java
@@ -0,0 +1,168 @@
+package me.maki325.ocelot;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import me.maki325.ocelot.command.OcelotCommand;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.level.block.Blocks;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.logging.Level;
+
+@SuppressWarnings("unused")
+public class OcelotConfig {
+    private static final List<String> HEADER = List.of(
+        "This is the main configuration file for Ocelot.",
+        "As you can see, there's tons to configure. Some options may impact gameplay, so use",
+        "with caution, and make sure you know what each option does before configuring.",
+        "",
+        "If you need help with the configuration or have any questions related to Ocelot,",
+        "join us in our Discord guild.",
+        "",
+        "Website: https://ocelot.maki325.me",
+        "Docs: https://ocelot.maki325.me/docs"
+    );
+    private static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    private static Map<String, Command> commands;
+
+    public static int version;
+    static boolean verbose;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignore) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load ocelot.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().setHeader(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("ocelot", new OcelotCommand("ocelot"));
+
+        version = getInt("config-version", 1);
+        set("config-version", 1);
+
+        readConfig(OcelotConfig.class, null);
+
+        Blocks.rebuildCache();
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Ocelot", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+
+    public static boolean sendOnlyVisibleBlockEntities = false;
+    private static void chunkSettings() {
+        sendOnlyVisibleBlockEntities = getBoolean("settings.chunk.send-only-visible-block-entities", sendOnlyVisibleBlockEntities);
+    }
+
+    public static String serverModName = "Ocelot";
+    private static void serverModName() {
+        serverModName = getString("settings.server-mod-name", serverModName);
+    }
+
+}
diff --git a/src/main/java/me/maki325/ocelot/blockentity/BlockEntityHelper.java b/src/main/java/me/maki325/ocelot/blockentity/BlockEntityHelper.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc9b43840f0dc2aac4edf10b1e55c849cb9937bb
--- /dev/null
+++ b/src/main/java/me/maki325/ocelot/blockentity/BlockEntityHelper.java
@@ -0,0 +1,148 @@
+package me.maki325.ocelot.blockentity;
+
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.Direction;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.util.Mth;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.chunk.LevelChunk;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+import net.minecraft.world.phys.shapes.CollisionContext;
+import net.minecraft.world.phys.shapes.VoxelShape;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+
+public class BlockEntityHelper {
+
+    public static BlockHitResult rayTraceBlockDirect(ServerLevel level, Vec3 vec3d, Vec3 vec3d1, BlockPos blockPos, BlockState blockState, CollisionContext voxelShapeCollision) {
+        if (blockState.isAir()) return null; // Tuinity - optimise air cases
+        VoxelShape voxelshape = ClipContext.Block.COLLIDER.get(blockState, level, blockPos, voxelShapeCollision);
+        return level.clipWithInteractionOverride(vec3d, vec3d1, blockPos, voxelshape, blockState);
+    }
+
+    public static BlockHitResult rayTraceDirect(ServerLevel level, Vec3 vec3d, Vec3 vec3d1, CollisionContext voxelShapeCollision) {
+        // most of this code comes from IBlockAccess#a(RayTrace, BiFunction, Function), but removes the needless functions
+        if (vec3d.equals(vec3d1)) {
+            return BlockHitResult.miss(vec3d1, Direction.DOWN, new BlockPos(vec3d1));
+        }
+
+        double endX = Mth.lerp(-1.0E-7D, vec3d1.x, vec3d.x);
+        double endY = Mth.lerp(-1.0E-7D, vec3d1.y, vec3d.y);
+        double endZ = Mth.lerp(-1.0E-7D, vec3d1.z, vec3d.z);
+
+        double startX = Mth.lerp(-1.0E-7D, vec3d.x, vec3d1.x);
+        double startY = Mth.lerp(-1.0E-7D, vec3d.y, vec3d1.y);
+        double startZ = Mth.lerp(-1.0E-7D, vec3d.z, vec3d1.z);
+
+        int currentX = Mth.floor(startX);
+        int currentY = Mth.floor(startY);
+        int currentZ = Mth.floor(startZ);
+
+        BlockPos.MutableBlockPos currentBlock = new BlockPos.MutableBlockPos(currentX, currentY, currentZ);
+
+        LevelChunk chunk = level.getChunkIfLoaded(currentBlock);
+        if (chunk == null) {
+            return BlockHitResult.miss(vec3d1, Direction.DOWN, new BlockPos(vec3d1));
+        }
+
+        net.minecraft.world.phys.BlockHitResult initialCheck = rayTraceBlockDirect(level, vec3d, vec3d1, currentBlock, chunk.getBlockState(currentBlock), voxelShapeCollision);
+
+        if (initialCheck != null) {
+            return initialCheck;
+        }
+
+        double diffX = endX - startX;
+        double diffY = endY - startY;
+        double diffZ = endZ - startZ;
+
+        int xDirection = Mth.sign(diffX);
+        int yDirection = Mth.sign(diffY);
+        int zDirection = Mth.sign(diffZ);
+
+        double normalizedX = xDirection == 0 ? Double.MAX_VALUE : (double) xDirection / diffX;
+        double normalizedY = yDirection == 0 ? Double.MAX_VALUE : (double) yDirection / diffY;
+        double normalizedZ = zDirection == 0 ? Double.MAX_VALUE : (double) zDirection / diffZ;
+
+        double normalizedXDirection = normalizedX * (xDirection > 0 ? 1.0D - Mth.frac(startX) : Mth.frac(startX));
+        double normalizedYDirection = normalizedY * (yDirection > 0 ? 1.0D - Mth.frac(startY) : Mth.frac(startY));
+        double normalizedZDirection = normalizedZ * (zDirection > 0 ? 1.0D - Mth.frac(startZ) : Mth.frac(startZ));
+
+        net.minecraft.world.phys.BlockHitResult result;
+
+        do {
+            if (normalizedXDirection > 1.0D && normalizedYDirection > 1.0D && normalizedZDirection > 1.0D) {
+                return BlockHitResult.miss(vec3d1, Direction.DOWN, new BlockPos(vec3d1));
+            }
+
+            if (normalizedXDirection < normalizedYDirection) {
+                if (normalizedXDirection < normalizedZDirection) {
+                    currentX += xDirection;
+                    normalizedXDirection += normalizedX;
+                } else {
+                    currentZ += zDirection;
+                    normalizedZDirection += normalizedZ;
+                }
+            } else if (normalizedYDirection < normalizedZDirection) {
+                currentY += yDirection;
+                normalizedYDirection += normalizedY;
+            } else {
+                currentZ += zDirection;
+                normalizedZDirection += normalizedZ;
+            }
+
+            currentBlock.set(currentX, currentY, currentZ);
+            if (chunk.getPos().x != currentBlock.getX() >> 4 || chunk.getPos().z != currentBlock.getZ() >> 4) {
+                chunk = level.getChunkIfLoaded(currentBlock);
+                if (chunk == null) {
+                    return BlockHitResult.miss(vec3d1, Direction.DOWN, new BlockPos(vec3d1));
+                }
+            }
+            result = rayTraceBlockDirect(level, vec3d, vec3d1, currentBlock, chunk.getBlockState(currentBlock), voxelShapeCollision);
+        } while (result == null);
+
+        return result;
+    }
+
+    public static boolean canPlayerSeeBlockEntity(@NotNull ServerPlayer serverPlayer, BlockPos blockPos, BlockEntity blockEntity) {
+        return canPlayerSeeBlockEntity(serverPlayer.visibleBlockEntities, serverPlayer.getLevel(), serverPlayer.position(), serverPlayer.getEyePosition(), blockPos, blockEntity);
+    }
+    public static boolean canPlayerSeeBlockEntity(ArrayList<Pair<BlockPos, BlockEntity>> visibleBlockEntities, ServerLevel serverLevel, Vec3 pos, Vec3 eye, BlockPos blockPos, BlockEntity blockEntity) {
+        boolean isVisibleForPlayer = visibleBlockEntities.stream().anyMatch(
+            pair -> pair.getFirst().equals(blockPos) && pair.getSecond().equals(blockEntity)
+        );
+        if(isVisibleForPlayer) return true;
+
+        BlockHitResult resultFeet = BlockEntityHelper.rayTraceDirect(
+            serverLevel,
+            pos,
+            blockPos.getCenter(),
+            CollisionContext.empty()
+        );
+
+        boolean feetMiss = resultFeet.getType() == HitResult.Type.MISS || !resultFeet.getBlockPos().equals(blockPos);
+
+        BlockHitResult resultEye = BlockEntityHelper.rayTraceDirect(
+            serverLevel,
+            eye,
+            blockPos.getCenter(),
+            CollisionContext.empty()
+        );
+        boolean eyeMiss = resultEye.getType() == HitResult.Type.MISS || !resultEye.getBlockPos().equals(blockPos);
+
+        if(eyeMiss && feetMiss) {
+            return false;
+        }
+
+        visibleBlockEntities.add(Pair.of(blockPos, blockEntity));
+
+        return true;
+    }
+
+}
diff --git a/src/main/java/me/maki325/ocelot/chunk/ChunkCheck.java b/src/main/java/me/maki325/ocelot/chunk/ChunkCheck.java
new file mode 100644
index 0000000000000000000000000000000000000000..020d79759fc5711a2377387bf33ee915ce329dcc
--- /dev/null
+++ b/src/main/java/me/maki325/ocelot/chunk/ChunkCheck.java
@@ -0,0 +1,117 @@
+package me.maki325.ocelot.chunk;
+
+import me.maki325.ocelot.blockentity.BlockEntityHelper;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.ChunkPos;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class ChunkCheck {
+
+    private final Thread chunkCheckThread;
+    private final List<CheckData> data;
+    private static final int TIME_DELTA_IN_MILLIS = 1000 / 20 * 2;
+
+    public ChunkCheck() {
+        this.chunkCheckThread = new Thread(this::run);
+        this.data = new ArrayList<>();
+    }
+
+    private void run() {
+        try {
+            while(!Thread.currentThread().isInterrupted()) {
+                synchronized (data) {
+                    data.removeIf(checkData -> {
+                        var currentMillis = System.currentTimeMillis();
+                        if(
+                            currentMillis >= checkData.timeAdded + TIME_DELTA_IN_MILLIS ||
+                            currentMillis >= checkData.timeFistAdded + 5 * TIME_DELTA_IN_MILLIS
+                        ) {
+                            final CheckData finalCheckData = checkData;
+                            MinecraftServer.getServer().execute(() -> {
+                                var lightEngine = finalCheckData.player.getLevel().chunkSource.chunkMap.lightEngine;
+                                List<Packet<?>> packets = new ArrayList<>();
+                                for(var chunkPos : finalCheckData.chunkPositions) {
+                                    var chunk = finalCheckData.player.getLevel().getChunk(chunkPos.x, chunkPos.z);
+                                    boolean shouldSend = false;
+                                    for(var entry : chunk.blockEntities.entrySet()) {
+                                        boolean visible = finalCheckData.player.visibleBlockEntities.stream().anyMatch(
+                                            pair -> pair.getFirst().equals(entry.getKey()) && pair.getSecond().equals(entry.getValue())
+                                        );
+                                        if(visible) continue;
+                                        boolean canSee = BlockEntityHelper.canPlayerSeeBlockEntity(finalCheckData.player, entry.getKey(), entry.getValue());
+                                        if(!canSee) continue;
+                                        shouldSend = true;
+                                        break;
+                                    }
+                                    if(!shouldSend) continue;
+                                    packets.add(new ClientboundLevelChunkWithLightPacket(
+                                        finalCheckData.player,
+                                        chunk,
+                                        lightEngine,
+                                        null,
+                                        null,
+                                        true,
+                                        true
+                                    ));
+                                }
+                                if(packets.isEmpty()) return;
+                                finalCheckData.player.connection.connection.sendAll(packets, null);
+                            });
+                            return true;
+                        }
+                        return false;
+                    });
+                }
+
+                Thread.sleep(TIME_DELTA_IN_MILLIS / 2);
+            }
+        } catch (InterruptedException ignored) {}
+    }
+
+    public synchronized void addChunk(ServerPlayer player, ChunkPos chunkPos) {
+        for(var checkData : this.data) {
+            if(checkData.player.equals(player)) {
+                if(checkData.chunkPositions.contains(chunkPos)) return;
+                checkData.timeAdded = System.currentTimeMillis();
+                checkData.chunkPositions.add(chunkPos);
+                return;
+            }
+        }
+        List<ChunkPos> chunkPositions = new ArrayList<>();
+        chunkPositions.add(chunkPos);
+        long currentTime = System.currentTimeMillis();
+        this.data.add(new CheckData(player, chunkPositions, currentTime, currentTime));
+    }
+
+    public void start() {
+        this.chunkCheckThread.start();
+    }
+
+    public void stop() {
+        this.chunkCheckThread.interrupt();
+    }
+
+    public void join() throws InterruptedException {
+        this.chunkCheckThread.join(10 * 1000);
+    }
+
+    static class CheckData {
+        ServerPlayer player;
+        List<ChunkPos> chunkPositions;
+        long timeFistAdded;
+        long timeAdded;
+
+        public CheckData(ServerPlayer player, List<ChunkPos> chunkPositions, long timeFistAdded, long timeAdded) {
+            this.player = player;
+            this.chunkPositions = chunkPositions;
+            this.timeFistAdded = timeFistAdded;
+            this.timeAdded = timeAdded;
+        }
+    }
+
+}
diff --git a/src/main/java/me/maki325/ocelot/command/OcelotCommand.java b/src/main/java/me/maki325/ocelot/command/OcelotCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4da0a764a60d1b8f54f07ebac62788354e233ee
--- /dev/null
+++ b/src/main/java/me/maki325/ocelot/command/OcelotCommand.java
@@ -0,0 +1,56 @@
+package me.maki325.ocelot.command;
+
+import me.maki325.ocelot.OcelotConfig;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class OcelotCommand extends Command {
+    public OcelotCommand(String name) {
+        super(name);
+        this.description = "Ocelot related commands";
+        this.usageMessage = "/ocelot [reload]";
+        this.setPermission("bukkit.command.ocelot");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length != 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "Please note that this command is not supported and may cause issues.");
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
+
+            MinecraftServer minecraftServer = MinecraftServer.getServer();
+            OcelotConfig.init((File) minecraftServer.options.valueOf("ocelot-settings"));
+            minecraftServer.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Ocelot config reload complete.");
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 52c7f83f525d150ce30e33f220d879d1d125508f..a92698163aa3ffe048cea9ae6cea461104d8a900 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -27,6 +27,7 @@ import io.netty.handler.timeout.TimeoutException;
 import io.netty.util.AttributeKey;
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.List; // Ocelot
 import java.util.Queue;
 import java.util.concurrent.RejectedExecutionException;
 import javax.annotation.Nullable;
@@ -36,16 +37,23 @@ import net.minecraft.network.chat.Component;
 import net.minecraft.network.chat.MutableComponent;
 import net.minecraft.network.protocol.Packet;
 import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundBlockUpdatePacket; // Ocelot
 import net.minecraft.network.protocol.game.ClientboundDisconnectPacket;
 import net.minecraft.network.protocol.login.ClientboundLoginDisconnectPacket;
 import net.minecraft.server.RunningOnDifferentThreadException;
 import net.minecraft.util.LazyLoadedValue;
 import net.minecraft.util.Mth;
+import net.minecraft.world.level.block.BaseEntityBlock; // Ocelot
 import org.apache.commons.lang3.Validate;
 import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
 
+// Ocelot start
+import me.maki325.ocelot.OcelotConfig;
+import me.maki325.ocelot.blockentity.BlockEntityHelper;
+// Ocelot end
+
 
 import io.netty.util.concurrent.AbstractEventExecutor; // Paper
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
@@ -365,7 +373,48 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.send(packet, (PacketSendListener) null);
     }
 
+    // Ocelot start - Makes it possible to send multiple messages with only one flush
+    public void sendAll(List<Packet<?>> packets, @Nullable PacketSendListener callbacks) {
+        if(packets.isEmpty()) return;
+        boolean connected = this.isConnected();
+        if (!connected && !preparing) {
+            return; // Do nothing
+        }
+        packets.forEach(packet-> packet.onPacketDispatch(getPlayer()));
+        // write the packets to the queue, then flush - antixray hooks there already
+        java.util.List<Connection.PacketHolder> packetHolders = new java.util.ArrayList<>(packets.size());
+
+        for (int i = 0, len = packets.size(); i < len;) {
+            Packet<?> extra = packets.get(i);
+            boolean end = ++i == len;
+            packetHolders.add(new Connection.PacketHolder(extra, end ? callbacks : null)); // append listener to the end
+        }
+        this.queue.addAll(packetHolders); // atomic
+
+        this.flushQueue();
+    }
+    // Ocelot end
+
     public void send(Packet<?> packet, @Nullable PacketSendListener callbacks) {
+        // Ocelot start - Don't send block entities that are not seen if enabled
+        if(OcelotConfig.sendOnlyVisibleBlockEntities) {
+            var player = this.getPlayer();
+            if(player != null && packet instanceof ClientboundBlockUpdatePacket blockUpdatePacket) {
+                var block = blockUpdatePacket.getBlockState().getBlock();
+                if(block instanceof BaseEntityBlock) {
+                    var blockEntity = player.getLevel().getBlockEntity(blockUpdatePacket.getPos());
+                    if(blockEntity != null) {
+                        var canSee = BlockEntityHelper.canPlayerSeeBlockEntity(player, blockUpdatePacket.getPos(), blockEntity);
+                        if(!canSee) {
+                            // System.out.println("Not sending ClientboundBlockUpdatePacket because the block entity can't be seen!");
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+        // Ocelot end
+
         // Paper start - handle oversized packets better
         boolean connected = this.isConnected();
         if (!connected && !preparing) {
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
index f3fa2678796c33f3a408a02a1995ad117eac9169..06c658baaacab44496d39762efa953d1656aac9e 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -19,6 +19,12 @@ import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.chunk.LevelChunkSection;
 import net.minecraft.world.level.levelgen.Heightmap;
 
+// Ocelot start
+import net.minecraft.server.level.ServerPlayer;
+import me.maki325.ocelot.OcelotConfig;
+import me.maki325.ocelot.blockentity.BlockEntityHelper;
+// Ocelot end
+
 public class ClientboundLevelChunkPacketData {
     private static final int TWO_MEGABYTES = 2097152;
     private final CompoundTag heightmaps;
@@ -33,9 +39,18 @@ public class ClientboundLevelChunkPacketData {
     }
     // Paper end
 
+    // Ocelot start - Check if we should send the block entity
+    private boolean shouldSend(@Nullable ServerPlayer serverPlayer, Map.Entry<BlockPos, BlockEntity> entry) {
+        if(serverPlayer == null) return true;
+        return BlockEntityHelper.canPlayerSeeBlockEntity(serverPlayer, entry.getKey(), entry.getValue());
+    }
+    // Ocelot end
+
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkPacketData(LevelChunk chunk) { this(chunk, null); }
-    public ClientboundLevelChunkPacketData(LevelChunk chunk, com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo) {
+    // Ocelot start - Pass player to check what block entities should be sent
+    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkPacketData(LevelChunk chunk) { this(null, chunk, null); }
+    public ClientboundLevelChunkPacketData(@Nullable ServerPlayer serverPlayer, LevelChunk chunk, com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo) {
+        // Ocelot end
         // Paper end
         this.heightmaps = new CompoundTag();
 
@@ -58,6 +73,11 @@ public class ClientboundLevelChunkPacketData {
         int totalTileEntities = 0; // Paper
 
         for(Map.Entry<BlockPos, BlockEntity> entry2 : chunk.getBlockEntities().entrySet()) {
+            // Ocelot start - Check if the block entity should be sent
+            if(OcelotConfig.sendOnlyVisibleBlockEntities && !shouldSend(serverPlayer, entry2)) {
+                continue;
+            }
+            // Ocelot end
             // Paper start
             if (++totalTileEntities > TE_LIMIT) {
                 var packet = entry2.getValue().getUpdatePacket();
diff --git a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
index 000853110c7a89f2d0403a7a2737025a5ac28240..b382b094d11e7fd0651fc5e70139c7ffc5e7da22 100644
--- a/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
+++ b/src/main/java/net/minecraft/network/protocol/game/ClientboundLevelChunkWithLightPacket.java
@@ -4,6 +4,7 @@ import java.util.BitSet;
 import javax.annotation.Nullable;
 import net.minecraft.network.FriendlyByteBuf;
 import net.minecraft.network.protocol.Packet;
+import net.minecraft.server.level.ServerPlayer; // Ocelot
 import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.chunk.LevelChunk;
 import net.minecraft.world.level.lighting.LevelLightEngine;
@@ -27,13 +28,15 @@ public class ClientboundLevelChunkWithLightPacket implements Packet<ClientGamePa
     // Paper end
 
     // Paper start - Anti-Xray - Add chunk packet info
-    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge) { this(chunk, lightProvider, skyBits, blockBits, nonEdge, true); }
-    public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks) {
+    // Ocelot start - Pass player
+    @Deprecated @io.papermc.paper.annotation.DoNotUse public ClientboundLevelChunkWithLightPacket(LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge) { this(null, chunk, lightProvider, skyBits, blockBits, nonEdge, true); }
+    public ClientboundLevelChunkWithLightPacket(ServerPlayer serverPlayer, LevelChunk chunk, LevelLightEngine lightProvider, @Nullable BitSet skyBits, @Nullable BitSet blockBits, boolean nonEdge, boolean modifyBlocks) {
         ChunkPos chunkPos = chunk.getPos();
         this.x = chunkPos.x;
         this.z = chunkPos.z;
         com.destroystokyo.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo = modifyBlocks ? chunk.getLevel().chunkPacketBlockController.getChunkPacketInfo(this, chunk) : null;
-        this.chunkData = new ClientboundLevelChunkPacketData(chunk, chunkPacketInfo);
+        this.chunkData = new ClientboundLevelChunkPacketData(serverPlayer, chunk, chunkPacketInfo);
+        // Ocelot end
         // Paper end
         this.lightData = new ClientboundLightUpdatePacketData(chunkPos, lightProvider, skyBits, blockBits, nonEdge);
         chunk.getLevel().chunkPacketBlockController.modifyBlocks(this, chunkPacketInfo); // Paper - Anti-Xray - Modify blocks
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index cea4447aad2d64db56a76e4ba180dc7326d2e13b..e005000f92a16c444dfe55f2054e856a9ae73817 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -192,6 +192,11 @@ import org.bukkit.event.player.AsyncPlayerChatPreviewEvent;
 import org.bukkit.event.server.ServerLoadEvent;
 // CraftBukkit end
 
+// Ocelot start
+import me.maki325.ocelot.chunk.ChunkCheck;
+import me.maki325.ocelot.OcelotConfig;
+// Ocelot end
+
 import co.aikar.timings.MinecraftTimings; // Paper
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements CommandSource, AutoCloseable {
@@ -302,6 +307,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final int TPS = 20;
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
     private static final int SAMPLE_INTERVAL = 20; // Paper
+    private final ChunkCheck chunkCheck;
     public final double[] recentTps = new double[ 4 ]; // Purpur
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations;
@@ -385,6 +391,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.options = options;
         this.worldLoader = worldLoader;
         this.vanillaCommandDispatcher = worldstem.dataPackResources().commands; // CraftBukkit
+        this.chunkCheck = new ChunkCheck();
         // Paper start - Handled by TerminalConsoleAppender
         // Try to see if we're actually running in a terminal, disable jline if not
         /*
@@ -1043,6 +1050,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         if (waitForShutdown) {
             try {
                 this.serverThread.join();
+                this.chunkCheck.stop();
+                this.chunkCheck.join();
             } catch (InterruptedException interruptedexception) {
                 MinecraftServer.LOGGER.error("Error while shutting down", interruptedexception);
             }
@@ -1128,6 +1137,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             // Paper start - move done tracking
             LOGGER.info("Running delayed init tasks");
             this.server.getScheduler().mainThreadHeartbeat(this.tickCount); // run all 1 tick delay tasks during init,
+            this.chunkCheck.start();
             // this is going to be the first thing the tick process does anyways, so move done and run it after
             // everything is init before watchdog tick.
             // anything at 3+ won't be caught here but also will trip watchdog....
@@ -1683,7 +1693,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @DontObfuscate
     public String getServerModName() {
-        return org.purpurmc.purpur.PurpurConfig.serverModName; // Purpur - Purpur > // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return OcelotConfig.serverModName; // Ocelot - Ocelot > // Purpur - Purpur > // Paper - Paper > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public SystemReport fillSystemReport(SystemReport details) {
@@ -2767,6 +2777,10 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         return executed;
     }
 
+    public ChunkCheck getChunkCheck() {
+        return chunkCheck;
+    }
+
     public final void executeMidTickTasks() {
         org.spigotmc.AsyncCatcher.catchOp("mid tick chunk task execution");
         long startTime = System.nanoTime();
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index fd1b0564d2d2b45128e6f2556fb93ee56bd683b5..162eb3802156f9bbf0d31be0f3be8920de745086 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -19,6 +19,7 @@ import java.util.Locale;
 import java.util.Optional;
 import java.util.function.BooleanSupplier;
 import javax.annotation.Nullable;
+import me.maki325.ocelot.OcelotConfig; // Ocelot
 import net.minecraft.DefaultUncaughtExceptionHandler;
 import net.minecraft.DefaultUncaughtExceptionHandlerWithName;
 import net.minecraft.SharedConstants;
@@ -227,6 +228,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         }
         org.purpurmc.purpur.PurpurConfig.registerCommands();
         // Purpur end
+        // Ocelot start
+        try {
+            OcelotConfig.init((java.io.File) options.valueOf("ocelot-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        OcelotConfig.registerCommands();
+        // Ocelot end
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // load version history now
         io.papermc.paper.brigadier.PaperBrigadierProviderImpl.INSTANCE.getClass(); // init PaperBrigadierProvider
         // Paper end
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 75965afd7b4bed23a5ecf618c7f91ff5e7ffd92f..862ae719e8984b3ead69af07574a9a2a1525210e 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -130,7 +130,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     public static final int FORCED_TICKET_LEVEL = 31;
     // Paper - rewrite chunk system
     public final ServerLevel level;
-    private final ThreadedLevelLightEngine lightEngine;
+    public final ThreadedLevelLightEngine lightEngine; // Ocelot - public
     public final BlockableEventLoop<Runnable> mainThreadExecutor; // Paper - public
     public ChunkGenerator generator;
     private final RandomState randomState;
@@ -1358,7 +1358,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         for (Iterator iterator = this.getPlayers(chunkcoordintpair, false).iterator(); iterator.hasNext(); entityplayer.trackChunk(chunkcoordintpair, (Packet) mutableobject.getValue())) {
             entityplayer = (ServerPlayer) iterator.next();
             Boolean shouldModify = chunk1.getLevel().chunkPacketBlockController.shouldModify(entityplayer, chunk1);
-            mutableobject.setValue(refreshPackets.computeIfAbsent(shouldModify, s -> new ClientboundLevelChunkWithLightPacket(chunk1, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s))); // Paper - Anti-Xray - Bypass
+
+            // Ocelot start - create final player, so we can pass it to calculate visible block entities
+            final ServerPlayer finalEntityPlayer = entityplayer;
+            mutableobject.setValue(refreshPackets.computeIfAbsent(shouldModify, s -> new ClientboundLevelChunkWithLightPacket(finalEntityPlayer, chunk1, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s))); // Paper - Anti-Xray - Bypass
+            // Ocelot end
         }
 
     }
@@ -1450,7 +1454,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 }
             }
             // Paper end - Fix MC-162253
-            return new ClientboundLevelChunkWithLightPacket(chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s);
+            return new ClientboundLevelChunkWithLightPacket(player, chunk, this.lightEngine, (BitSet) null, (BitSet) null, true, (Boolean) s); // Ocelot - pass the player, so we can calculate visible block entities
         }));
         // Paper end
         DebugPackets.sendPoiPacketsForChunk(this.level, chunk.getPos());
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 8664b5cfc739fc6b57643210cac3d03b279a59a1..1899ce10c06758fde196e15d61074c2b7378ac6f 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -4,6 +4,7 @@ import com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent;
 import com.google.common.collect.Lists;
 import com.mojang.authlib.GameProfile;
 import com.mojang.datafixers.util.Either;
+import com.mojang.datafixers.util.Pair; // Ocelot
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
@@ -13,6 +14,7 @@ import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
 import java.util.OptionalInt;
+import java.util.ArrayList; // Ocelot
 import javax.annotation.Nullable;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
@@ -274,6 +276,8 @@ public class ServerPlayer extends Player {
     private boolean tpsBar = false; // Purpur
     private boolean compassBar = false; // Purpur
 
+    public ArrayList<Pair<BlockPos, BlockEntity>> visibleBlockEntities; // Ocelot - block entities that the player can see
+
     public ServerPlayer(MinecraftServer server, ServerLevel world, GameProfile profile) {
         super(world, world.getSharedSpawnPos(), world.getSharedSpawnAngle(), profile);
         this.chatVisibility = ChatVisiblity.FULL;
@@ -373,6 +377,7 @@ public class ServerPlayer extends Player {
         this.maxHealthCache = this.getMaxHealth();
         this.cachedSingleMobDistanceMap = new com.destroystokyo.paper.util.PooledHashSets.PooledObjectLinkedOpenHashSet<>(this); // Paper
         this.spawnInvulnerableTime = world.purpurConfig.playerSpawnInvulnerableTicks; // Purpur
+        this.visibleBlockEntities = new ArrayList<>(); // Ocelot
     }
 
     // Yes, this doesn't match Vanilla, but it's the best we can do for now.
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 04652735fad2d2ef5bd4d08d85ac2df10be7e75d..ac2e6137f6a8987666b546963e1c9b0391cc790c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -28,6 +28,7 @@ import java.util.function.UnaryOperator;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+import me.maki325.ocelot.OcelotConfig; // Ocelot
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
@@ -175,6 +176,7 @@ import net.minecraft.world.level.block.entity.SignBlockEntity;
 import net.minecraft.world.level.block.entity.StructureBlockEntity;
 import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.ChunkPos; // Ocelot
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.BlockHitResult;
 import net.minecraft.world.phys.HitResult;
@@ -1656,6 +1658,17 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
 
                                     // Skip the first time we do this
                                     if (from.getX() != Double.MAX_VALUE) {
+                                        // Ocelot start - add chunks to check for visible block entities
+                                        if(OcelotConfig.sendOnlyVisibleBlockEntities) {
+                                            var chunkPos = this.player.chunkPosition();
+                                            for(int x = chunkPos.x - 1;x <= chunkPos.x + 1;x++) {
+                                                for(int z = chunkPos.z - 1;z <= chunkPos.z + 1;z++) {
+                                                    MinecraftServer.getServer().getChunkCheck().addChunk(this.player, new ChunkPos(x, z));
+                                                }
+                                            }
+                                        }
+                                        // Ocelot end
+
                                         Location oldTo = to.clone();
                                         PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                                         this.cserver.getPluginManager().callEvent(event);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index c34c5368e336ba4b181a95932a9b40cb4f50ae1d..8574365d0cc445242ee08d02b4a8ccaadf7fffef 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -386,6 +386,7 @@ public abstract class PlayerList {
             net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = worldserver1.registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME)
                 .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
             player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
+                player, // Ocelot - pass the player, so we can calculate visible block entities
                 new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
                 worldserver1.getLightEngine(), null, null, true, false)
             );
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 076d6733c87d040b9da33c6845c63194f3b93ef4..6e8fbdc25b195f1976dd5032bb3a761aeae395ad 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1033,6 +1033,7 @@ public final class CraftServer implements Server {
         org.spigotmc.SpigotConfig.init((File) console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
         org.purpurmc.purpur.PurpurConfig.init((File) console.options.valueOf("purpur-settings")); // Purpur
+        me.maki325.ocelot.OcelotConfig.init((File) console.options.valueOf("purpur-settings")); // Ocelot
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters, config.spawnAnimals); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 9b5323edd99848b73ea0e34230e7bec8dc23be8c..e2d0501e6da08ea96d196a1c2306e66e3906dc94 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -514,7 +514,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
                     Boolean shouldModify = chunk.getLevel().chunkPacketBlockController.shouldModify(player, chunk);
                     player.connection.send(refreshPackets.computeIfAbsent(shouldModify, s -> { // Use connection to prevent creating firing event
-                        return new ClientboundLevelChunkWithLightPacket(chunk, this.world.getLightEngine(), null, null, true, (Boolean) s);
+                        return new ClientboundLevelChunkWithLightPacket(player, chunk, this.world.getLightEngine(), null, null, true, (Boolean) s); // Ocelot - pass the player, so we can calculate visible block entities
                     }));
                     // Paper end
                 }
diff --git a/src/main/java/org/bukkit/craftbukkit/Main.java b/src/main/java/org/bukkit/craftbukkit/Main.java
index 576cd8e20982bb20d10213b6c7a229428eec1c2f..55aebe1da20d5c5545f49ab2533e64568257b156 100644
--- a/src/main/java/org/bukkit/craftbukkit/Main.java
+++ b/src/main/java/org/bukkit/craftbukkit/Main.java
@@ -180,6 +180,14 @@ public class Main {
                         .describedAs("Yml file");
                 // Purpur end
 
+                // Ocelot start
+                acceptsAll(asList("ocelot", "ocelot-settings"), "File for ocelot settings")
+                    .withRequiredArg()
+                    .ofType(File.class)
+                    .defaultsTo(new File("ocelot.yml"))
+                    .describedAs("Yml file");
+                // Ocelot end
+
                 // Paper start
                 acceptsAll(asList("server-name"), "Name of the server")
                         .withRequiredArg()
